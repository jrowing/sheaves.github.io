---
layout: post
title: The Group Ring and the Regular Representation
draft_tag: 
- Representation Theory
---

In the [previous post]({% post_url 2015-02-02-Representation-Theory-Decomposing-Representations%}){:target="_blank"}, we saw how to decompose a given group representation into irreducibles. But we still don't know much about the irreducible representations of a (finite) group. What do they look like? How many are there? And is there even a finite number of irreducible representations?

In this post, we'll construct the [group ring](http://en.wikipedia.org/wiki/Group_ring){:target="_blank"} of a group. Treating this as a vector space, we get the [regular representation](http://en.wikipedia.org/wiki/Regular_representation){:target="_blank"}, which turns out to contain *all* the irreducible representations of $G$!

<!--more-->

## The group ring $FG$

Given a (finite) group $G$ and a field $F$, we can treat each element of $G$ as a basis element of a vector space over $F$. The resulting vector space generated by $g \in G$ is

$$
FG := \left\{\sum_{g\in G} \alpha_g g: \alpha_g \in F \right\}.
$$


Let's do this is Sage with the group $G = D_4$ and the field $F = \mathbb{Q}$:

*(The Sage cells in this post are linked, so things may not work if you don't execute them in order.)*

<div class="linked">
  <script type="text/x-sage">
G = DihedralGroup(4)
F = QQ

FG = GroupAlgebra(G,F)

v = FG.an_element()
v
  </script>
</div>

We can view $v \in FG$ as vector in $F^n$, where $n = |G|$: 

<div class="linked">
  <script type="text/x-sage">
v.to_vector()
  </script>
</div>

Here, we're treating each $g \in G$ as a basis element of $FG$

<div class="linked">
  <script type="text/x-sage">
for g in G:
    g = FG(g)
    print "{} = {}".format(g.to_vector(),g)
  </script>
</div>

Vectors in $FG$ are added component-wise:

$$
\left(\sum_{g \in G} \alpha_g g\right) + \left(\sum_{g\in G} \beta_g g\right) = \sum_{g \in G} (\alpha_g+\beta_g) g.
$$

<div class="linked">
  <script type="text/x-sage">
w = FG.random_element()  
print 'w = {}'.format(w.to_vector())
print 'v + w = {}'.format((v + w).to_vector())
  </script>
</div>

In fact $FG$ is also a  *ring* (called the [**group ring**](http://en.wikipedia.org/wiki/Group_ring){:target="_blank"}), because we can multiply vectors using the multiplication rule of the group $G$:

$$
\left(\sum_{h \in G} \alpha_h h\right) \left(\sum_{g\in G} \beta_g g\right) = \sum_{h,g \in G} (\alpha_h \beta_g) hg.
$$

<div class="linked">
  <script type="text/x-sage">
print 'v * w = {}'.format((v * w).to_vector())
  </script>
</div>

## Multiplication as a linear transformation

We can treat multiplication by $v \in FG$ as a function

$$
\begin{align*}
T_v: FG &\to FG \\
w &\mapsto vw.
\end{align*}
$$

One can check that each $T_v$ is a linear transformation! We can thus represent $T_v$ as a matrix whose columns are $T_v(g), g \in G$:

<div class="linked">
  <script type="text/x-sage">
for g in G:
    g = FG(g)
    print "v*{} = {}".format(g.to_vector(),(v*g).to_vector())

T = matrix([(v*FG(g)).to_vector() for g in G]).transpose()
show(T)
  </script>
</div>

## The regular representation

We're especially interested in $T_g, g \in G$. These are invertible, with inverse $T_{g^{-1}}$, and their matrices are all permutation matrices, because multiplying by $g \in G$ simply permutes elements of $G$:

<div class="linked">
  <script type="text/x-sage">
for v in G:
    v = FG(v)
    show(matrix([(v*FG(g)).to_vector() for g in G]).transpose())
  </script>
</div>

Define a function $\rho_{FG}$ which assigns the each $g\in G$ the corresponding $T_g$:

$$
\begin{align*}
\rho_{FG}: G &\to \mathrm{GL}(FG) \\
g &\mapsto T_g
\end{align*}
$$

Then $(FG,\rho_{FG})$ is the [**regular representation**](http://en.wikipedia.org/wiki/Regular_representation){:target="_blank"} of $G$ over $F$. 

The regular representation of any group with $|G| > 1$ is not irreducible. In fact, it is a direct sum of *all* the irreducible representations of $G$! What's more, if $(V,\rho)$ is an irreducible representation of $G$ and $\dim V = k$, then $V$ occurs $k$ times in the direct-sum decomposition of $FG$!

Let's apply the decomposition algorithm in the [previous post]({% post_url 2015-02-02-Representation-Theory-Decomposing-Representations%}){:target="_blank"} to $(FG,\rho_{FG})$:

<div class="linked">
  <script type="text/x-sage">
# Define the regular representation
def rho(h):
    h = FG(h)
    return matrix([(v*FG(g)).to_vector() for g in G]).transpose()

# Find non-scalar H that commutes with all elements of G
def is_irreducible(rho,G):
  """
  If rho is irreducible, returns (True, I)  where I is the n-by-n identity matrix.
  Otherwise, returns (False, H) where H is a non-scalar matrix that commutes with rho(G).
  """
  # Compute the dimension of the representation
  n = rho(G.identity()).dimensions()[0]
  
  # Run through all r,s = 1,2,...,n
  for r in range(n):
      for s in range(n):
          # Define H_rs
          H_rs = matrix.zero(QQbar,n)
          if r == s:
              H_rs[r,s] = 1
          elif r > s:
              H_rs[r,s] = 1
              H_rs[s,r] = 1
          else: # r < s
              H_rs[r,s] = I
              H_rs[s,r] = -I
          
          # Compute H
          H = sum([rho(g).conjugate_transpose()*H_rs*rho(g) for g in G])/G.cardinality()
          
          # Check if H is scalar
          if H[0,0]*matrix.identity(n) != H:
              return False,H
  
  # If all H are scalar
  return True, matrix.identity(n)

is_irred,H = is_irreducible(rho,G)

# Compute J,P such that H = PJP^(-1)
J,P = H.jordan_form(QQbar,transformation=True)

# Compute block subdivisions (just for aesthetics)
edges = []
for g in G:
    edges += (P.conjugate_transpose()*rho(g)*P).nonzero_positions()
graph = Graph(edges)
graph.remove_loops()
graph.remove_multiple_edges()
subrep_indices = graph.connected_components()
subdivisions = graph.vertices()[1:]
for l in subrep_indices:
    for i in l[1:]:
        subdivisions.remove(i)
      
# Display rho in block-diagonal form
for g in G:
    M = P.inverse()*rho(g)*P
    M.subdivide(subdivisions, subdivisions)
    show(M)
  </script>
</div>











